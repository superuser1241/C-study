#JOIN 복습
SELECT * FROM DEPT;
SELECT * FROM EMP;
SELECT * FROM EMP, DEPT;
SELECT COUNT(*) FROM EMP, DEPT;

#EMPNO,ENAME,DEPTNO,LOC를 이용한 JOIN 테이블 만들기
SELECT EMPNO, ENAME, DEPTNO, LOC 
FROM EMP E, DEPT D
WHERE E.DEPTNO=D.DEPTNO;

#급여가 2000초과인 사원들의 부서정보,
#사원정보를 출력해보세요

#급여 범위를 지정하는 조건식으로 JOIN
SELECT * FROM SALGRADE;
SELECT ENAME,SAL FROM EMP;

#비 등가 JOIN
SELECT * FROM EMP E, SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL;

#자체 JOIN
SELECT * FROM EMP E, EMP C
WHERE E.MGR = C.EMPNO;

#8-8
SELECT E1.EMPNO, E1.ENAME, E1.MGR,
       E2.EMPNO AS MGR_EMPNO,
       E2.ENAME AS MGR_ENAME
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.MGR;

# OUTER JOIN
SELECT * FROM EMP;
SELECT COUNT(*) FROM EMP;
SELECT * FROM EMP WHERE ENAME ='KING';

#일반적인 등가JOIN (NULL값을 가지면 포함하지 않는다)
SELECT E1.EMPNO, E1.ENAME, E1.MGR,
       E2.EMPNO AS MGR_EMPNO,
       E2.ENAME AS MGR_ENAME
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO;

#LEFT OUTER JOIN
SELECT E1.EMPNO, E1.ENAME, E1.MGR,
       E2.EMPNO AS MGR_EMPNO,
       E2.ENAME AS MGR_ENAME
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO(+);

#RIGHT OUTER JOIN
SELECT E1.EMPNO, E1.ENAME, E1.MGR,
       E2.EMPNO AS MGR_EMPNO,
       E2.ENAME AS MGR_ENAME
FROM EMP E1, EMP E2
WHERE E1.MGR(+) = E2.EMPNO;

#ANSI표준
#SQL-99
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR,
       E.HIREDATE, E.SAL, E.COMM,
       DEPTNO,D.DNAME, D.LOC
FROM EMP E NATURAL JOIN DEPT D
ORDER BY DEPTNO, E.EMPNO;

#234페이지
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR,
       E.HIREDATE, E.SAL, E.COMM,
       D.DEPTNO, D.DNAME, D.LOC
FROM EMP E JOIN DEPT D ON(E.DEPTNO=D.DEPTNO)
ORDER BY E.DEPTNO, EMPNO;

#8-14 LEFT OUTER JOIN
SELECT E1.EMPNO, E1.ENAME, E1.MGR,
       E2.EMPNO AS MGR_EMPNO,
       E2.ENAME AS MGR_ENAME
FROM EMP E1 LEFT OUTER JOIN EMP E2 ON(E1.MGR=E2.EMPNO)
ORDER BY E1.EMPNO;

#8-15 RIGHT OUTER JOIN으로 위 쿼리를 작성해주세요
SELECT E1.EMPNO, E1.ENAME, E1.MGR,
       E2.EMPNO AS MGR_EMPNO,
       E2.ENAME AS MGR_ENAME
FROM EMP E1 RIGHT OUTER JOIN EMP E2 ON(E1.MGR=E2.EMPNO)
ORDER BY E1.EMPNO;

#문제3번
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.JOB, E.SAL FROM EMP E, DEPT D
WHERE E.DEPTNO(+)=D.DEPTNO
ORDER BY D.DEPTNO, E.ENAME;

SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, JOB, SAL 
FROM EMP E RIGHT OUTER JOIN DEPT D ON(E.DEPTNO=D.DEPTNO)
ORDER BY D.DEPTNO, E.ENAME;

#서브쿼리(SUB QUERY)
#사원 이름이 JONES인 사원의 급여는?
SELECT SAL FROM EMP
WHERE ENAME = 'JONES';

#급여가 2975보다 높은 사원정보 출력
SELECT * FROM EMP
WHERE SAL>2975;

#급여가 JONES보다 높은 사원의 정보 출력
SELECT ENAME, SAL FROM EMP
WHERE SAL > (SELECT SAL FROM EMP
WHERE ENAME = 'JONES');

#KING 보다 급여가 많은사람은?
SELECT ENAME, SAL FROM EMP
WHERE SAL>(SELECT SAL FROM EMP WHERE ENAME='KING');

#EMP테이블의 사원정보중에서 사원이름이 ALLEN인 사원의 추가수당(COMM)보다 많이 받는 사원 정보를 구하시오
SELECT * FROM EMP
WHERE COMM >(SELECT COMM FROM EMP WHERE ENAME='ALLEN');

#9-4 서브쿼리의 결과값이 날짜형의 경우(ALLEN보다 입사일이 빠른 직원?)
SELECT * FROM EMP
WHERE HIREDATE < (SELECT HIREDATE FROM EMP WHERE ENAME='ALLEN');

#9-5 평균급여보다 많이 받는 직원들의 정보는?
SELECT E.EMPNO, E.ENAME, E.JOB, E.SAL, D.DEPTNO, D.DNAME, D.LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO=D.DEPTNO AND E.DEPTNO=20 AND E.SAL > (SELECT AVG(SAL) FROM EMP);

#다중행 연산자(매우중요)
#IN 메인 쿼리의 데이터가 서브 쿼리의 결과중 하나라도 일치한 데이터가 있다면 TRUE
#ANY, SOME 메인쿼리의 조건식을 만족하는 서브쿼리의 결과가 하나 이상이면 TRUE
#ALL 메인쿼리의 조건식을 서브쿼리의 결과 모두가 만족하면 TRUE
#EXISTS 서브쿼리의 결과가 존재하면(즉, 행이 1개 이상일 경우)TRUE
#실행결과가 여러개인 쿼리를 확인

#IN 연산자
SELECT * FROM EMP
WHERE DEPTNO IN(20,30);

# 각 부서별 최고급여와 동일한 급여를 받는 사원정보 출력
SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO;
SELECT * FROM EMP
WHERE SAL IN(SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO)
ORDER BY DEPTNO;

#ANY
SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO;
SELECT * FROM EMP
WHERE SAL = ANY(SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO)
ORDER BY DEPTNO;

#SOME
SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO;
SELECT * FROM EMP
WHERE SAL=SOME(SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO)
ORDER BY DEPTNO;

#ANY 30번 부서 사원들의 최대 급여보다 적은 급여를 받는 사원정보 출력하기
SELECT SAL FROM EMP WHERE DEPTNO=30;

SELECT * FROM EMP
WHERE SAL < ANY(SELECT SAL FROM EMP WHERE DEPTNO=30)
ORDER BY SAL, EMPNO;

# 9-14 ALL
#30번 부서번호 인 사원들의 최소 급여보다 더 적은 급여를 받는 직원은?
SELECT SAL FROM EMP WHERE DEPTNO =30;

SELECT * FROM EMP
WHERE SAL < ALL(SELECT SAL FROM EMP WHERE DEPTNO =30);

#EXISTS 연산자
#서브쿼리에 값이 존재하는 경우!!!
SELECT DNAME FROM DEPT WHERE DEPTNO =10;
#EMP 테이블에 회계부서가 존재하는가???
SELECT * FROM EMP
WHERE EXISTS    (SELECT DNAME FROM DEPT WHERE DEPTNO=10);
#없는 50번의 부서 문의:??
SELECT * FROM EMP
WHERE EXISTS (SELECT DNAME FROM DEPT WHERE DEPTNO=50);
#비교할 열이 여러개인 다중열 서브쿼리
SELECT DEPTNO, MAX(SAL) FROM EMP
GROUP BY DEPTNO;

SELECT * FROM EMP
WHERE (DEPTNO, SAL) IN  (SELECT DEPTNO, MAX(SAL) FROM EMP
GROUP BY DEPTNO);

#연습문제1번 262페이지
SELECT JOB, EMPNO, ENAME, SAL, D.DEPTNO, DNAME
FROM EMP E JOIN DEPT D ON(E.DEPTNO=D.DEPTNO)
WHERE JOB IN(SELECT JOB FROM EMP WHERE ENAME='ALLEN');

# 연습문제2번
SELECT E.EMPNO, E.ENAME, D.DNAME, E.HIREDATE, D.LOC, E.SAL, S.GRADE
FROM EMP E JOIN DEPT D ON(E.DEPTNO=D.DEPTNO)
     JOIN SALGRADE S ON(E.SAL BETWEEN LOSAL AND HISAL)
WHERE E.SAL > (SELECT AVG(SAL) FROM EMP)
ORDER BY SAL DESC, EMPNO;

#DEPT테이블이 있다. 복사해보자 ---.DEPT_TEMP
CREATE TABLE DEPT_TEMP
AS SELECT * FROM DEPT;

SELECT * FROM DEPT_TEMP

INSERT INTO DEPT_TEMP(DEPTNO, DNAME, LOC)
VALUES(80,'MOBILE');

#날짜 데이터 입력
CREATE TABLE EMP_TEMP
AS SELECT * FROM EMP
WHERE 1 <> 1;

SELECT * FROM EMP_TEMP;

INSERT INTO EMP_TEMP
VALUES (1111,'성춘향','PRESIDENT',NULL,TO_DATE('07/01/2001','DD/MM/YYYY'),5000,1000,10);

SELECT * FROM EMP_TEMP;

INSERT INTO EMP_TEMP
VALUES (8888,'성춘향','PRESIDENT',NULL,SYSDATE,5000,1000,10);

#UPDATE
DROP DEPT_TEMP2;
CREATE TABLE DEPT_TEMP2
AS SELECT * FROM DEPT;

SELECT * FROM DEPT_TEMP2;
COMMIT;

UPDATE DEPT_TEMP2
SET LOC = 'SEOUL';

ROLLBACK;

#DELETE
SELECT * FROM DEPT_TEMP2;

DELETE FROM DEPT_TEMP2
WHERE DEPTNO=40;
DELETE FROM DEPT_TEMP2
WHERE DNAME='SALES';
